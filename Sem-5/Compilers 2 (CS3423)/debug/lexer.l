%option noyywrap yylineno nodefault
/* %option c++ */

D               [0-9]
L               [a-zA-Z]


%{
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>
    #include "astNodes.h"
    #include "parser.hh"

    #define YY_USER_ACTION update_locations(); // Called before each token
    void comment();
    void update_locations();

    extern YYLTYPE yylloc;
%}

%%
"#"                    {comment();}

"const"                 {return CONST;}
"var"                   {return VAR;}

"bool"                  {return BOOL;}
"float"                 {return FLOAT;}
"int"                   {return INT;}
"string"                {return STRING;}
"void"                  {return VOID;}
"Point"                 {return POINT;}
"Path"                  {return PATH;}                  
"Image"                 {return IMAGE;}
"Rectangle"             {return RECTANGLE;}
"Circle"                {return CIRCLE;}
"Ellipse"               {return ELLIPSE;}
"Polygon"               {return POLYGON;}
"Curve"                 {return CURVE;}
"Pi"                    {return PI;}
"Colour"                {return COLOUR;}

{D}+                   {yylval.valuei = atoi(yytext);return INTEGER_LITERAL;}
{D}+"."{D}+            {yylval.valuef = atof(yytext);return FLOAT_LITERAL;}
\"([^\\\"]|\\.)*\"     {*(yytext + yyleng - 1) = '\0'; yytext++; return STRING_LITERAL;}
"true"                 {yylval.valueb = true; return BOOL_LITERAL;}
"false"                {yylval.valueb = false; return BOOL_LITERAL;}

"if"                   {return IF;}
"else"                 {return ELSE;}
"switch"               {return SWITCH;}
"case"                 {return CASE;}
"default"              {return DEFAULT;}
"while"                {return WHILE;}
"for"                  {return FOR;}
"break"                {return BREAK;}
"continue"             {return CONTINUE;}
"send"                 {return SEND;} 

"family"               {return FAMILY;}
"::"                   {return INHERITS;}  
"public"               {return PUBLIC;}
"private"              {return PRIVATE;}

"driver"               {return DRIVER;}

{L}({L}|{D}|_)*        {auto temp = new string(yytext);yylval.id = temp; return IDENTIFIER;}

","                    {return ',';}
":="                   {return ASSIGN;}
"+="                   {return ADD_ASSIGN;}
"-="                   {return SUB_ASSIGN;}
"*="                   {return MUL_ASSIGN;}
"/="                   {return DIV_ASSIGN;}
"%="                   {return MOD_ASSIGN;}
"?"                    {return '?';}
":"                    {return ':';}
"|"                    {return LOGICAL_OR;}
"&"                    {return LOGICAL_AND;}
"="                    {return EQ;}
"!="                   {return NOT_EQ;}
"<"                    {return LS_THAN;}
"<="                   {return LS_THAN_EQ;}
">"                    {return GR_THAN;}
">="                   {return GR_THAN_EQ;}
"+"                    {return '+';}
"-"                    {return '-';}
"*"                    {return '*';}
"/"                    {return '/';}
"%"                    {return '%';}
"++"                   {return INC;}
"--"                   {return DEC;}
"!"                    {return LOGICAL_NOT;}
("<:"|"(")             {return '(';}
(":>"|")")             {return ')';}
"["                    {return '[';}
"]"                    {return ']';}
">>"                   {return SCOPE_ACCESS;}
"(:"                   {return '{';}
":)"                   {return '}';}
";"                    {return ';';}

[ \t\v\n\f]*           {}

 /* Matches to any invalid tokens not matched to any other rules */
.                      {
                        printf("Error: %s: Line %d:%d\t%-12s - Invalid token\n", yylloc.filename.c_str(), yylineno, yylloc.first_column, yytext);
                        fprintf(stderr, "   Error: %s: Line %d:%d - '%s' - Invalid token\n", yylloc.filename.c_str(), yylineno, yylloc.first_column, yytext);
                        return YYUNDEF;
                       }
%%

void update_locations(){
    yylloc.first_line = yylloc.last_line = yylineno;
    yylloc.first_column = yylloc.last_column;

    for(int i = 0; yytext[i] != '\0'; i++) {
        if(yytext[i] == '\n'){
            yylloc.last_line++;
            yylloc.last_column = 0;
        }
        else if(yytext[i] == '\t')
            yylloc.last_column += 4 - (yylloc.last_column % 4);
        else
            yylloc.last_column++;
    }
}

void comment(){
        char c;
        while( (c = yyinput()) != '\n' )
            ; /* eats up any line starting with '#' */
}

#ifdef STANDALONE_LEXER

// The token names generated by bison in parser.tab.c. yytname[i] gives the name of the token with enum value 255 + i;
static const char *const yytname[] =
{
    "end of file", "error", "invalid token", "CONST", "VAR", "BOOL",
    "FLOAT", "INT", "STRING", "VOID", "BOOL_LITERAL", "FLOAT_LITERAL",
    "INTEGER_LITERAL", "STRING_LITERAL", "IF", "ELSE", "SWITCH", "CASE",
    "DEFAULT", "WHILE", "FOR", "BREAK", "CONTINUE", "SEND", "FAMILY",
    "INHERITS", "PUBLIC", "PRIVATE", "DRIVER", "IDENTIFIER", "','", "ASSIGN",
    "ADD_ASSIGN", "SUB_ASSIGN", "MUL_ASSIGN", "DIV_ASSIGN", "MOD_ASSIGN",
    "'?'", "':'", "LOGICAL_OR", "LOGICAL_AND", "EQ", "NOT_EQ", "LS_THAN",
    "LS_THAN_EQ", "GR_THAN", "GR_THAN_EQ", "'+'", "'-'", "'*'", "'/'", "'%'",
    "INC", "DEC", "INC_POST", "DEC_POST", "UPLUS", "UMINUS", "LOGICAL_NOT",
    "'('", "')'", "'['", "']'", "SCOPE_ACCESS", "';'", "'{'", "'}'",
};
YYLTYPE yylloc;
YYSTYPE yylval;

void print_tokens_matched(){
    int token;
    while(token = yylex()){
        char token_name[20] = "'''";
        if(token < 255) 
            token_name[1] = token;
        else
            strcpy(token_name, yytname[token - 255]);
        printf("%s: Line %d:%d\t%-12s was matched to the token %-20s (= %d) \n", yylloc.filename.c_str(), yylloc.first_line, yylloc.first_column, yytext, token_name, token);
    }
    printf("\n");
}

void init_yylloc(std::string filename){
	yylloc.first_line = yylloc.last_line = yylineno = 1;
	yylloc.first_column = yylloc.last_column = 0;
	yylloc.filename = filename;
}

int main(int argc, char* argv[]){
    if(argc < 2){ /* just read stdin */
        init_yylloc("(stdin)");
        print_tokens_matched();
    }
    else{
        for(int i = 1; i < argc; i++){
            init_yylloc(argv[i]);
            FILE *file = fopen(argv[i], "r");
            if(file == NULL){ 
                perror(argv[i]); 
                return 1;
            }
            yyrestart(file);
            print_tokens_matched();
            fclose(file);
        }
    }

    return 0;
}

#endif
